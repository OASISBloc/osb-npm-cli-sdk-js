// Copyright (c) 2019 Foundation OASIS LTD. All Rights Reserved.
// OASISBloc Client SDK code distributed under the GPLv3 license, see LICENSE file.

const Buffer = require('buffer').Buffer
const Eosjs = require('eosjs')
const EosjsEcc = require('eosjs-ecc')
const crypto = require('crypto')
const eccrypto = require('eccrypto')
const bs58 = require('bs58')
const bitwise = require('bitwise')
const axios = require('axios')
const fetch = require('node-fetch')

const DATA_STATUS_AVAILABLE = 0
const SECP256K1_TYPE = 714
const PUBKEY_PREFIX = 'OSB'
//const allowedNumberOfFragment = [ 1, 2 ]
const allowedNumberOfFragment = [ 1, 2, 4, 8 ]

module.exports = class {
	constructor (c) {
		this.osb = {
			chainAccessPoint: c.chainAccessPoint,
			chainId: c.chainId,
			dataTradeContractName: c.dataTradeContractName,
			privateKey: c.privateKey,
			account: c.account
		}
		
		const config_eosjs_api = {
		  chainId: c.chainId,
		  httpEndpoint: c.chainAccessPoint,
		  broadcast: true,
		  verbose: false,
		  sign: true,
		  keyProvider: c.privateKey,
			//  expireInSeconds: 60
		}
		this.eosjs = Eosjs(config_eosjs_api)
		
		this.allowedNumberOfFragment = allowedNumberOfFragment
		
		this.eventCallback = function(msg) { console.log(msg) }
	}
	
	async sleep(seconds) {
		console.log('sleeping for 2 sec...')
		return new Promise(r => setTimeout(r(), seconds))
	}
	
	setEventCallback(c) {
		this.eventCallback = c
	}
	
	async adddatabegin(data, datatypename, price, detailFields, period, decryptKeyList) {
//		console.log('adddatabegin()')
		const osb = this
		return new Promise(async function(resolve, reject) {
			const dataSize = data.length
			
			// validating the parameters
			if (!Buffer.isBuffer(data)) {
				osb.eventCallback('error! - data must be a type of Buffer')
				reject('error! - data must be a type of Buffer')
				return
			}
			
			if (!osb.allowedNumberOfFragment.includes(decryptKeyList.length)) {
				osb.eventCallback('error! - decryptKeyList.length must be 1, 2, 4 or 8 ')
				reject('error! - decryptKeyList.length must be 1, 2, 4 or 8 ')
				return
			}
			
			const numberOfFragment = decryptKeyList.length
			
			// getting the original hash
			const originalDataHash = osb.getDataHash(data)
			osb.eventCallback('Getting the original data hash: ' + originalDataHash)
			
			
			// fragmentation
			const frag = osb.fragmentize(data, numberOfFragment)
			osb.eventCallback('The data is fragmentized: ' + numberOfFragment)
			osb.eventCallback('Getting hashes of original fragments...')
			// getting the hashes from original fragments
			var fragmentHashOriginal = []
			for (var i=0; i < numberOfFragment; i++) {
				fragmentHashOriginal[i] = osb.getDataHash(frag[i])
				osb.eventCallback(`${i}: ${fragmentHashOriginal[i]}`)
			}
			osb.eventCallback('Encrypting fragments...')
			
			// encrypting fragments
			var encryptedFrag = []
			var encryptKeyList = []
			for (var i=0; i < numberOfFragment; i++) {
				const encryptKey = EosjsEcc.privateToPublic(decryptKeyList[i], PUBKEY_PREFIX)
				encryptKeyList.push( encryptKey )
				encryptedFrag[i] = await osb.encode(frag[i], encryptKey)
				
				osb.eventCallback(decryptKeyList[i] + ' - ' + EosjsEcc.privateToPublic(decryptKeyList[i], PUBKEY_PREFIX))
			}
			
			osb.eventCallback('Getting hashes of encrypted fragments...')
			
			// getting the hashes from encrypted fragments
			var fragmentHashEncrypted = []
			for (var i=0; i < numberOfFragment; i++) {
				fragmentHashEncrypted[i] = osb.getDataHash(encryptedFrag[i])
				osb.eventCallback(`${i}: ${fragmentHashEncrypted[i]}`)
			}
			
			
			osb.eventCallback()
			
			// registering data by pushing the action 'addDataBegin' to mainnet
			var fragments = []
			for (var i=0; i < numberOfFragment; i++) {
				fragments[i] = {
					fragment_no: i+1,
					size: encryptedFrag[i].length,
					hash_original: fragmentHashOriginal[i],
					hash_encrypted: fragmentHashEncrypted[i],
					cid: '',
					idfs_cluster_id: 0,
					encrypt_key: encryptKeyList[i]
				}
			}
			osb.eventCallback('fragments:')
			osb.eventCallback(fragments)
	
			const result = await osb.eosjs.transaction({
				actions: [{
			      account: osb.osb.dataTradeContractName,
			      name: 'adddatabegin',
			      authorization: [{
			        actor: osb.osb.account,
			        permission: 'active',
			      }],
			      data: {
			    	provider: osb.osb.account,				//데이터 제공자 계정명
		    	    datatype_name: datatypename,			//데이터 타입명
		    	    price: String(price) + " OSB",			//데이터 구매 가격 (단위: 0.0001 OSB)
		    	    detail_fields: detailFields,			//데이터 추가 필드 값
		    	    period: period,							//데이터 보관 기간 (단위: 일)
		    	    data_hash_original: originalDataHash,	//원본 데이터 해시 값 (해싱 알고리즘: SHA256)
		    	    size: dataSize,							//원본 데이터 사이즈 (단위: byte)
		    	    fragments: fragments,					//데이터 조각
			      },
			    }]
			}, {
			  blocksBehind: 3,
			  expireSeconds: 30,
			}).catch(function (error) {
				osb.eventCallback(error)
				reject(error)
				return
			})
			
			osb.eventCallback('Pushing an action of adddatabegin()')
			osb.eventCallback({
		    	provider: osb.osb.account,				//데이터 제공자 계정명
	    	    datatype_name: datatypename,			//데이터 타입명
	    	    price: String(price),					//데이터 구매 가격 (단위: 0.0001 OSB)
	    	    detail_fields: detailFields,			//데이터 추가 필드 값
	    	    period: period,							//데이터 보관 기간 (단위: 일)
	    	    data_hash_original: originalDataHash,	//원본 데이터 해시 값 (해싱 알고리즘: SHA256)
	    	    size: dataSize,							//원본 데이터 사이즈 (단위: byte)
	    	    fragments: fragments,					//데이터 조각
		      })
		    osb.eventCallback('adddatabegin() result: ')
			osb.eventCallback(result)
		    
		    resolve({
				originalDataHash: originalDataHash,
				encryptedFrag: encryptedFrag,
				fragments: fragments,
				encryptKeyList: encryptKeyList,
				txResultAddDataBegin: result
			})
		})
	}
	
	async checkIfFinishToAddDataBegin(originalDataHash) {
		this.eventCallback('checkIfFinishToAddDataBegin()')
		const osb = this
		return new Promise(async function(resolve, reject) {
			// retrieving idfs clusters and their idfs node information for each fragment
			const dataList = await osb.eosjs.getTableRows({
		        json: true,
		        code: osb.osb.dataTradeContractName,
		        scope: osb.osb.dataTradeContractName,
		        table: "data",
		        table_key: "data_id",
		        limit: 5,
		        reverse: true
		    }).catch(function(error) {
		        osb.eventCallback(error)
		        reject('failed to retrieve data list')
		    });
			
			osb.eventCallback('Getting table rows of dataList is done')
			
			var dataRow = false
			for (var i=0; i < dataList.rows.length; i++) {
				if (dataList.rows[i].data_hash_original === originalDataHash) {
					dataRow = dataList.rows[i]
					
					osb.eventCallback(dataRow)
					const result = {
						dataRow: dataRow
					}
					resolve(result)
				}
			}
		})
	}
	
	async uploadData(
			providerAccount,
			dataTradeContractAccount,
			dataId,
			encryptedFrag,
			fragments,
			encryptKeyList,
			decryptKeyList) {
		this.eventCallback('uploadData()')
		const osb = this
		return new Promise(async function(resolve, reject) {
			// Making a list of idfsList
			var idfsList = []
			for (var f=0; f < fragments.length; f++) {
				idfsList[f] = await osb.getIdfsList(fragments[f].idfs_cluster_id)
			}
			osb.eventCallback('idfsList:')
			osb.eventCallback(idfsList)
			
			// uploading each fragment to IDFS node, and received CIDs
			for (var c=0; c < idfsList.length; c++) {
				osb.eventCallback('uploading fragment no: ' + (c+1))
				
				const ret = await osb.uploadDataToIdfs(idfsList[c][0], {
					provider_account: providerAccount,
					contract_addr: dataTradeContractAccount,
					reserved_data_id: dataId,
					fragment_no: c + 1,
					decrypt_key: decryptKeyList[c],
					data: encryptedFrag[c],
					is_data_encrypted: true
				}).catch(function (err) {
					osb.eventCallback(err)
					reject(err)
				})
				
				osb.eventCallback("Response from idfs for uploading data")
				osb.eventCallback(ret)
	
				// register cid to fragments
				fragments[c].fragment_no = c + 1
				fragments[c].cid = ret.cid
				fragments[c].encrypt_key = encryptKeyList[c]
				
				// uploading decrypt-keys of fragments to IDFS in each cluster
				for (var i=1; i < idfsList[c].length; i++) {
					// encrypting decrypt-keys for each IDFS provider
					const ret = await osb.uploadDecryptKeyToIdfs(idfsList[c][i], {
						provider_account: providerAccount,
						contract_addr: dataTradeContractAccount,
						reserved_data_id: dataId,
						fragment_no: c + 1,
						decrypt_key: decryptKeyList[c],
						cid: fragments[c].cid
					}).catch(function (err) {
						osb.eventCallback(err)
						reject(err)
					})
					
					osb.eventCallback(`Uploading decrypt key of fragment(${fragments[c].fragment_no}) for IDFS provider(${c}) is done`)
					osb.eventCallback("Response from idfs for uploading decrypt key")
					osb.eventCallback(ret)
				}
			}
			osb.eventCallback(fragments)
			resolve({
				fragments: fragments
			})
		})
	}
	
	async addDataEnd(fragments, dataId) {
		const osb = this
		return new Promise(async function(resolve, reject) {
			osb.eventCallback('Pushing an action addDataEnd()')
			osb.eventCallback(JSON.stringify({
				actions: [{
			      account: osb.osb.dataTradeContractName,
			      name: 'adddataend',
			      authorization: [{
			        actor: osb.osb.account,
			        permission: 'active',
			      }],
			      data: {
			    	provider: osb.osb.account,				//데이터 제공자 계정명
		    	    data_id: dataId,			//데이터 타입명
		    	    fragments: fragments,					//데이터 조각
			      },
			    }]
			}))
			const result = await osb.eosjs.transaction({
				actions: [{
			      account: osb.osb.dataTradeContractName,
			      name: 'adddataend',
			      authorization: [{
			        actor: osb.osb.account,
			        permission: 'active',
			      }],
			      data: {
			    	provider: osb.osb.account,				//데이터 제공자 계정명
		    	    data_id: dataId,			//데이터 타입명
		    	    fragments: fragments,					//데이터 조각
			      },
			    }]
			}, {
			  blocksBehind: 3,
			  expireSeconds: 30,
			}).catch(function (error) {
				osb.eventCallback(error)
				reject(error)
				return
			})
			osb.eventCallback(result)
			resolve({
				txResultAddDataEnd: result
			})
		})
	}

	/* The type of data is Buffer */
	async registerData(data, datatypename, detailFields, price, period, decryptKeyList) {
		const osb = this
		return new Promise(async function(resolve, reject) {
			const resultAddDataBegin = await osb.adddatabegin(data, datatypename, price, detailFields, period, decryptKeyList)
			.catch(function(error) {
		        osb.eventCallback(error)
		        reject(error)
		    })
			
		    const resultAfterAddBegin = await osb.checkIfFinishToAddDataBegin(resultAddDataBegin.originalDataHash)
			.catch(function(error) {
		        osb.eventCallback(error)
		        reject(error)
		    })
			
			const resultUpload = await osb.uploadData(
					osb.osb.account,
					osb.osb.dataTradeContractName,
					resultAfterAddBegin.dataRow.data_id,
					resultAddDataBegin.encryptedFrag,
					resultAfterAddBegin.dataRow.fragments,
					resultAddDataBegin.encryptKeyList,
					decryptKeyList)
			.catch(function(error) {
		        osb.eventCallback(error)
		        reject(error)
		    })
			
			const resultAddDataEnd = await osb.addDataEnd(resultUpload.fragments, resultAfterAddBegin.dataRow.data_id)
			.catch(function(error) {
		        osb.eventCallback(error)
		        reject(error)
		    })
			
		    const resultAfterAddEnd = await osb.checkIfFinishToAddDataBegin(resultAddDataBegin.originalDataHash)
			.catch(function(error) {
		        osb.eventCallback(error)
		        reject(error)
		    })
			
			const ret = {
				txResultAddDataBegin: resultAddDataBegin.txResultAddDataBegin,
				txResultAddDataEnd: resultAddDataEnd.txResultAddDataEnd,
				dataRegistrationInfo: resultAfterAddEnd
			}
    		resolve(ret)
    	})
	}
	
	/* The return value is data in Buffer */
	async buyData(dataId, buyerPrivateKey) {
		this.eventCallback(`buyData(${dataId}, ${buyerPrivateKey})`)
		
		const osb = this
		return new Promise(async function(resolve, reject) {
			// TODO validating of the parameters
			const buyerPublicKey = EosjsEcc.privateToPublic(buyerPrivateKey, PUBKEY_PREFIX) 
			
			// TODO checking if the data id is available to buy
			const dataList = await osb.eosjs.getTableRows({
		        json: true,
		        code: osb.osb.dataTradeContractName,
		        scope: osb.osb.dataTradeContractName,
		        table: "data",
		        table_key: "data_id",
		        lower_bound: dataId,
		        upper_bound: dataId + 1,
		        limit: 5,
		        reverse: true
		    }).catch(function(error) {
		        osb.eventCallback(error)
		        osb.eventCallback('failed to retrieve data list')
		        reject(error)
		    });
			
			const dataRow = dataList.rows[0]
			if (dataRow.status !== DATA_STATUS_AVAILABLE) {
				osb.eventCallback('The data is not available')
				reject('The data is not available')
				return
			}
			osb.eventCallback('dataRow:')
			osb.eventCallback(dataRow)
			
			// acquiring an authority to access data to buy by pushing an action 'buyData' to mainnet
			osb.eventCallback('buydata action data')
			osb.eventCallback({
			      account: osb.osb.dataTradeContractName,
			      name: 'buydata',
			      authorization: [{
			        actor: osb.osb.account,
			        permission: 'active',
			      }],
			      data: {
			    	  user: osb.osb.account,
			          data_id: dataId,
			          buyer_key: buyerPublicKey
			      },
			    })
			
			const resultBuy = await osb.eosjs.transaction({
				actions: [{
			      account: osb.osb.dataTradeContractName,
			      name: 'buydata',
			      authorization: [{
			        actor: osb.osb.account,
			        permission: 'active',
			      }],
			      data: {
			    	  user: osb.osb.account,
			          data_id: dataId,
			          buyer_key: buyerPublicKey
			      },
			    }]
			}, {
			  blocksBehind: 3,
			  expireSeconds: 30,
			}).catch(function (error) {
				osb.eventCallback(error)
				reject(error)
				//return // 구매했어도 아래의 상황을 진행할 수 있게 주석처리?
			})
			
			// TODO get buy_id from buyhistory by using resultBuy transaction info.
			const buyhistoryList = await osb.eosjs.getTableRows({
		        json: true,
		        code: osb.osb.dataTradeContractName,
		        scope: osb.osb.dataTradeContractName,
		        table: "buyhistory",
		        table_key: "buy_id",
		        limit: 5,
		        reverse: true
		    }).catch(function(error) {
		        osb.eventCallback(error)
		        osb.eventCallback('failed to retrieve data list')
				reject(error)
		    })
			var buyhistory = false
			for (var i=0; i<buyhistoryList.rows.length; i++) {
				if (buyhistoryList.rows[i].buyer === osb.osb.account &&
					parseInt(buyhistoryList.rows[i].data_id) === parseInt(dataId)) {
					buyhistory = buyhistoryList.rows[i]
					break
				}
			}
			if (!buyhistory) {
		        osb.eventCallback('Cannot find the buy history')
				reject('Cannot find the buy history')
				return
			}
			
			var fragments = []
			for (var c = 0; c < dataRow.fragments.length; c++) {
				// retrieving data, idfs clusters and their idfs node information for each fragment
				const idfsList = await osb.getIdfsList(dataRow.fragments[c].idfs_cluster_id)
				const idfs = idfsList[0]
				
				osb.eventCallback(dataRow.fragments[c].cid)
				
				// downloading data fragment
				const resGetData = await axios.get('http://' + idfs.ipaddr + ':' + idfs.port + '/v0/get_data', {
			    	params: {
			    		cid: dataRow.fragments[c].cid
			    	}
			    }).catch( err => { osb.eventCallback(err); } ); // ERROR
				
				osb.eventCallback('Response for the request to download data fragment')
				osb.eventCallback(resGetData.data)
				
				const resFetch = await fetch(resGetData.data.data_url)
				const encryptedFragment = await resFetch.buffer()
				
				const resGetDecryptKey = await axios.get('http://' + idfs.ipaddr + ':' + idfs.port + '/v0/get_decrypt_key', {
			    	params: {
			    		data_id: dataRow.data_id,
			    		fragment_no: dataRow.fragments[c].fragment_no,
			    	    cid: dataRow.fragments[c].cid,
			    	    buy_id: buyhistory.buy_id,
			    	    buyer_account: osb.osb.account,
			    	    buyer_key: buyerPublicKey
			    	}
			    }).catch( err => {
			    		osb.eventCallback(err)
						reject(err)
			    	}
			    ) // ERROR
				
				if (!resGetDecryptKey.data.result) {
					reject(resGetDecryptKey.data.msg)
				}
				
				const encryptedDecryptKeyBuffer = Buffer(resGetDecryptKey.data.decrypt_key)
				osb.eventCallback('Response to the request to get decrypt key:')
				osb.eventCallback(encryptedDecryptKeyBuffer)
				
				// decrypting decrypt-keys by using buyerPrivateKey
				const decryptKeyBuffer = await osb.decode(encryptedDecryptKeyBuffer, buyerPrivateKey)
				
				osb.eventCallback('Decrypt Key:')
				osb.eventCallback(decryptKeyBuffer.toString())
				
				// decrypting data fragments by using decrypt-keys
				fragments[c] = await osb.decode(encryptedFragment, decryptKeyBuffer.toString())
			}

			bitwise.bits.toString(bitwise.buffer.read(fragments[0]), 4, ' ')
			bitwise.bits.toString(bitwise.buffer.read(fragments[1]), 4, ' ')
			
			// merging fragments
			const data = osb.merge(fragments, dataRow.size)
			osb.eventCallback('Merged data:')
			osb.eventCallback(data.toString())
			
			// getting and checking the hash of the merged data
			const mergedDataHash = osb.getDataHash(data)
			if (dataRow.data_hash_original !== mergedDataHash) {
				osb.eventCallback(`Error - the original hash is unmatched to that of the merged data (original hash: ${dataRow.data_hash_original}, merged data hash: ${mergedDataHash})`)
				reject(`Error - the original hash is unmatched to that of the merged data (original hash: ${dataRow.data_hash_original}, merged data hash: ${mergedDataHash})`)
				return
			}
			
			// returning data
			resolve({
				data: data,
				txResultBuyData: resultBuy,
				dataBuyHistoryInfo: buyhistory
			})
		})
	}
	
	getDataHash(data) {
		// validating the parameter
		if (!Buffer.isBuffer(data)) {
			this.eventCallback('data shoud be Buffer')
			return
		}
		
		const digest = crypto.createHash('sha256').update(data).digest()
		const digestSize = Buffer.from(digest.byteLength.toString(16), 'hex')
		const hashFunction = Buffer.from('12', 'hex') // 0x20
		const combined = Buffer.concat([hashFunction, digestSize, digest])
		const calculatedDataHash = bs58.encode(combined)
		return calculatedDataHash
	}
	
	async getIdfsList(cluster_id) {
		const osb = this
		return new Promise(async function(resolve, reject) {
			const idfsList = await osb.eosjs.getTableRows({
		        json: true,
		        code: osb.osb.dataTradeContractName,
		        scope: osb.osb.dataTradeContractName,
		        table: "idfs",
		        table_key: "getcluster",
		        lower_bound: cluster_id,
		        upper_bound: cluster_id,
		        key_type: "i64",
		        index_position: 2
		    }).catch(function(error) {
		        osb.eventCallback(error)
		        reject('failed to retrieve idfs list')
		    });
			
			var idfsListByClusterId = [];
			for (var i=0; i < idfsList.rows.length; i++) {
				if (idfsList.rows[i].cluster_id === cluster_id) {
					idfsListByClusterId.push(idfsList.rows[i])
				}
			}
			
			resolve(idfsListByClusterId)
		})
	}
	
	async uploadDataToIdfs(idfs, data) {
		const osb = this
		return new Promise(async function(resolve, reject) {
			const encryptedDecryptkeyBuffer = await osb.encode(Buffer.from(data.decrypt_key), idfs.idfs_public_key)
		    const response = await axios({
		    	url: 'http://' + idfs.ipaddr + ':' + idfs.port + '/v0/add_data',
		    	method: 'post',
		    	data: {
		    		provider_account: data.provider_account,
			        contract_addr: data.contract_addr,
			        reserved_data_id: data.reserved_data_id,
			        fragment_no: data.fragment_no,
			        decrypt_key: encryptedDecryptkeyBuffer,
			        data_type: data.data_type,
			        data: data.data,
			        is_data_encrypted: data.is_data_encrypted
		    	}
		    }).catch( err => {
		    	osb.eventCallback(err)
				reject(err)
			}); // ERROR
			
			if (!response.data.result) {
				osb.eventCallback(response.data.msg)
				reject(response.data.msg)
			}
        
    		const encryptKey = EosjsEcc.privateToPublic(data.decrypt_key, PUBKEY_PREFIX)
    		if (response.data.encrypt_key === encryptKey) {
    			resolve(response.data)
    		} else {
    			reject(`The encrypt key returned from IDFS is unmatched (expected: ${encryptKey}, received: ${response.data.encrypt_key})`)
    		}
    	})
	}
	
	async uploadDecryptKeyToIdfs (idfs, data) {
		this.eventCallback('uploadDecryptKeyToIdfs()')
		const osb = this
		return new Promise(async function(resolve, reject) {
			const encryptedDecryptkeyBuffer = await osb.encode(Buffer.from(data.decrypt_key), idfs.idfs_public_key)
			
			osb.eventCallback({
		        provider_account: data.provider_account,
		        contract_addr: data.contract_addr,
		        reserved_data_id: data.reserved_data_id,
		        fragment_no: data.fragment_no,
		        decrypt_key: encryptedDecryptkeyBuffer.toString(),
		        cid: data.cid
		    })
		    
		    const response = await axios({
		    	url: 'http://' + idfs.ipaddr + ':' + idfs.port + '/v0/upload_decrypt_key',
		    	method: 'post',
		    	data: {
		    		provider_account: data.provider_account,
			        contract_addr: data.contract_addr,
			        reserved_data_id: data.reserved_data_id,
			        fragment_no: data.fragment_no,
			        decrypt_key: encryptedDecryptkeyBuffer,
			        cid: data.cid
		    	}
		    }).catch( err => {
		    	osb.eventCallback(err)
				reject(response.msg)
			}); // ERROR
			
			if (!response.data.result) {
				osb.eventCallback(response.data.msg)
				reject(response.data.msg)
			}
        
    		const encryptKey = EosjsEcc.privateToPublic(data.decrypt_key, PUBKEY_PREFIX)
    		if (response.data.encrypt_key === encryptKey) {
    			resolve(response.data)
    		} else {
    			reject(`The encrypt key returned from IDFS is unmatched (expected: ${encryptKey}, received: ${response.data.encrypt_key})`)
    		}
    	})
	}
	
	async setAuthForContract() {
		this.eventCallback('setAuthForContract()')
		const auth = {
			threshold: 1,
			keys: [{
				key: EosjsEcc.privateToPublic(this.osb.privateKey, PUBKEY_PREFIX),
				weight: 1
			}],
			accounts: [{
				permission: {
					actor: this.osb.dataTradeContractName,
					permission: "eosio.code"
				},
				weight: 1
			}],
			waits: [{
				wait_sec: 2,
				weight: 1
			}]
		}

		const result = await this.eosjs.transaction({
			actions: [{
			    account: 'eosio',
			    name: 'updateauth',
			    authorization: [{
			      actor: this.osb.account,
			      permission: 'active',
			    }],
			    data: {
			    	account: this.osb.account,
				    permission: 'active',
				    parent: 'owner',
				    auth: auth
			    }
			}]
		}, {
		  blocksBehind: 3,
		  expireSeconds: 30,
		}).catch( err => { osb.eventCallback(err); } ); // ERROR
		
		osb.eventCallback('result:')
		osb.eventCallback(result)
		
		return result
	}
	
	async encode(data, encryptKey) {
		const encryptKeyBuffer = bs58.decode(encryptKey.slice(PUBKEY_PREFIX.length)).slice(0, 33)
		const opts = await eccrypto.encrypt(encryptKeyBuffer, data)
		
		//assert(opts.iv.length === 16, "Bad IV")
	    //assert(opts.ephemPublicKey.length === 65, "Bad public key")
	    //assert(opts.mac.length === 32, "Bad MAC")
	    // 16 + 2 + 2 + 32 + 2 + 32 + ? + 32
	    var buf = new Buffer(118 + opts.ciphertext.length)
	    opts.iv.copy(buf)
	    buf.writeUInt16BE(SECP256K1_TYPE, 16, true)  // Curve type
	    buf.writeUInt16BE(32, 18, true)  // Rx length
	    opts.ephemPublicKey.copy(buf, 20, 1, 33)  // Rx
	    buf.writeUInt16BE(32, 52, true)  // Ry length
	    opts.ephemPublicKey.copy(buf, 54, 33)  // Ry
	    opts.ciphertext.copy(buf, 86)
	    opts.mac.copy(buf, 86 + opts.ciphertext.length)
	    return buf
	}
	
	async decode (buf, decryptKey) {
		//assert(buf.length >= 118, "Buffer is too small")
	    //assert(buf.readUInt16BE(16, true) === SECP256K1_TYPE, "Bad curve type")
	    //assert(buf.readUInt16BE(18, true) === 32, "Bad Rx length")
	    //assert(buf.readUInt16BE(52, true) === 32, "Bad Ry length")
	    var iv = new Buffer(16)
	    buf.copy(iv, 0, 0, 16)
	    var ephemPublicKey = new Buffer(65)
	    ephemPublicKey[0] = 0x04
	    buf.copy(ephemPublicKey, 1, 20, 52)
	    buf.copy(ephemPublicKey, 33, 54, 86)
	    // NOTE(Kagami): We do copy instead of slice to protect against
	    // possible source buffer modification by user.
	    var ciphertext = new Buffer(buf.length - 118)
	    buf.copy(ciphertext, 0, 86, buf.length - 32)
	    var mac = new Buffer(32)
	    buf.copy(mac, 0, buf.length - 32)
	    const encryptedData = {
	      iv: iv,
	      ephemPublicKey: ephemPublicKey,
	      ciphertext: ciphertext,
	      mac: mac,
	    }
		
		const decryptKeyBuffer = bs58.decode(decryptKey).slice(1, 33);
	    const data = await eccrypto.decrypt(decryptKeyBuffer, encryptedData);
		return data
	}
	
	fragmentize(data, numberOfFragment) {
		var frag = []
		for (var i=0; i < numberOfFragment; i++) {
			frag[i] = Buffer.alloc( Math.ceil(data.length / numberOfFragment) )
		}
		
		const bitsDivided = 8 / numberOfFragment
		for (var i=0; i < data.length; i++) {
			for (var j=0; j < numberOfFragment; j++) {
				bitwise.buffer.modify(frag[j], bitwise.buffer.read(data, i*8 + j*bitsDivided, bitsDivided), i*bitsDivided)
			}
		}
		return frag
	}
	
	merge(fragments, mergedDataLength) {
		this.eventCallback(`merge(${mergedDataLength})`)
		this.eventCallback(fragments[0])
		this.eventCallback(fragments[1])
		var mergedData = Buffer.alloc(mergedDataLength)
		for (var i = 0; i < mergedDataLength; i++) {
			bitwise.buffer.modify(mergedData, bitwise.buffer.read(fragments[0], i*4, 4), i*8)
			bitwise.buffer.modify(mergedData, bitwise.buffer.read(fragments[1], i*4, 4), i*8+4)
		}
		return mergedData
	}
	
	async test(data, data_id, buyerPrivateKey) {
		const osb = this
		const ret = await this.buyData(data_id, buyerPrivateKey)
		.catch(function (error) {
			osb.eventCallback('ERROR!!!')
			osb.eventCallback(error)
			return
		})
		const returnedData = ret.data
		
		this.eventCallback( "Original data: " + data )
		this.eventCallback( "Returned data: " + returnedData )
		this.eventCallback( "Original data string: " + data.toString() )
		this.eventCallback( "Returned data string: " + returnedData.toString() )
		this.eventCallback( "Original bits: " + bitwise.bits.toString(bitwise.buffer.read(data), 4, ' ') )
		this.eventCallback( "Returned bits: " + bitwise.bits.toString(bitwise.buffer.read(returnedData), 4, ' ') )
		this.eventCallback( "Original hash: " + osb.getDataHash(data))
		this.eventCallback( "Returned hash: " + osb.getDataHash(returnedData))
	}
}


